From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Rhagon <Rhagon1337@gmail.com>
Date: Tue, 8 Feb 2022 02:08:57 +0100
Subject: [PATCH] Implemented new capturing method


diff --git a/src/main/java/io/papermc/paper/util/Handle.java b/src/main/java/io/papermc/paper/util/Handle.java
new file mode 100644
index 0000000000000000000000000000000000000000..f148f317e70443a70322ee1517dbf3e0e503aaf0
--- /dev/null
+++ b/src/main/java/io/papermc/paper/util/Handle.java
@@ -0,0 +1,19 @@
+package io.papermc.paper.util;
+
+public class Handle<T> {
+
+    private T value;
+
+    public Handle(T initialValue) {
+        this.value = initialValue;
+    }
+
+    public void setValue(T value) {
+        this.value = value;
+    }
+
+    public T getValue() {
+        return this.value;
+    }
+
+}
diff --git a/src/main/java/net/minecraft/core/dispenser/DispenseItemBehavior.java b/src/main/java/net/minecraft/core/dispenser/DispenseItemBehavior.java
index 59db245fe11384282af84ec1d5be08ab0e9484ca..098dd846fad6a22e6201f0d1ffbad66b8eef7ccf 100644
--- a/src/main/java/net/minecraft/core/dispenser/DispenseItemBehavior.java
+++ b/src/main/java/net/minecraft/core/dispenser/DispenseItemBehavior.java
@@ -803,17 +803,15 @@ public interface DispenseItemBehavior {
                         return stack;
                     }
                 }
-
-                worldserver.captureTreeGeneration = true;
-                // CraftBukkit end
-
-                if (!BoneMealItem.growCrop(stack, worldserver, blockposition) && !BoneMealItem.growWaterPlant(stack, worldserver, blockposition, (Direction) null)) {
-                    this.setSuccess(false);
-                } else if (!worldserver.isClientSide) {
-                    worldserver.levelEvent(1505, blockposition, 0);
-                }
-                // CraftBukkit start
-                worldserver.captureTreeGeneration = false;
+                //Paper start - encapsulate capturing
+                worldserver.captureTreeGeneration(() -> {
+                        if (!BoneMealItem.growCrop(stack, worldserver, blockposition) && !BoneMealItem.growWaterPlant(stack, worldserver, blockposition, (Direction) null)) {
+                            this.setSuccess(false);
+                        } else if (!worldserver.isClientSide) {
+                            worldserver.levelEvent(1505, blockposition, 0);
+                        }
+                    });
+                //Paper end
                 if (worldserver.capturedBlockStates.size() > 0) {
                     TreeType treeType = SaplingBlock.treeType;
                     SaplingBlock.treeType = null;
@@ -821,7 +819,8 @@ public interface DispenseItemBehavior {
                     List<org.bukkit.block.BlockState> blocks = new java.util.ArrayList<>(worldserver.capturedBlockStates.values());
                     worldserver.capturedBlockStates.clear();
                     StructureGrowEvent structureEvent = null;
-                    if (treeType != null) {
+                    boolean grewTree = treeType != null;
+                    if (grewTree) {
                         structureEvent = new StructureGrowEvent(location, treeType, false, null, blocks);
                         org.bukkit.Bukkit.getPluginManager().callEvent(structureEvent);
                     }
diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index 66f808cabcf6a9a6584849b285f1c60133adc7b4..65fd2494393ff1bfc22272c8fd2f7434a3ed1f2e 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -21,6 +21,8 @@ import java.util.Random;
 import java.util.function.Consumer;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.util.Handle; //Paper
 import net.minecraft.tags.BlockTags;
 import net.minecraft.tags.Tag;
 import net.minecraft.tags.TagContainer;
@@ -314,30 +316,38 @@ public final class ItemStack {
             CompoundTag oldData = this.getTagClone();
             int oldCount = this.getCount();
             ServerLevel world = (ServerLevel) itemactioncontext.getLevel();
-
+            //Paper start - split logic from foreign variables
+            boolean notABucket = false;
+            boolean isBoneMeal = false;
+            //Paper end
             if (!(this.getItem() instanceof BucketItem || this.getItem() instanceof SolidBucketItem)) { // if not bucket
-                world.captureBlockStates = true;
+                notABucket = true; //Paper
                 // special case bonemeal
                 if (this.getItem() == Items.BONE_MEAL) {
-                    world.captureTreeGeneration = true;
+                    isBoneMeal = true; //Paper
                 }
             }
             Item item = this.getItem();
-            InteractionResult enuminteractionresult = item.useOn(itemactioncontext);
+            //Paper start - encapsulate capturing
+            Handle<InteractionResult> resultHandle = new Handle<>(null);
+            itemactioncontext.getLevel().capture(() -> resultHandle.setValue(item.useOn(itemactioncontext)), notABucket, isBoneMeal);
+            InteractionResult enuminteractionresult = resultHandle.getValue();
+            //Paper end
             CompoundTag newData = this.getTagClone();
             int newCount = this.getCount();
             this.setCount(oldCount);
             this.setTagClone(oldData);
-            world.captureBlockStates = false;
-            if (enuminteractionresult.consumesAction() && world.captureTreeGeneration && world.capturedBlockStates.size() > 0) {
-                world.captureTreeGeneration = false;
+            if (enuminteractionresult.consumesAction() && isBoneMeal && world.capturedBlockStates.size() > 0) { //Paper
                 Location location = new Location(world.getWorld(), blockposition.getX(), blockposition.getY(), blockposition.getZ());
                 TreeType treeType = SaplingBlock.treeType;
                 SaplingBlock.treeType = null;
                 List<BlockState> blocks = new java.util.ArrayList<>(world.capturedBlockStates.values());
                 world.capturedBlockStates.clear();
                 StructureGrowEvent structureEvent = null;
-                if (treeType != null) {
+                //Paper start - introduce new variable
+                boolean grewTree = treeType != null;
+                if (grewTree) {
+                    //Paper end
                     boolean isBonemeal = this.getItem() == Items.BONE_MEAL;
                     structureEvent = new StructureGrowEvent(location, treeType, isBonemeal, (Player) entityhuman.getBukkitEntity(), blocks);
                     org.bukkit.Bukkit.getPluginManager().callEvent(structureEvent);
@@ -361,7 +371,6 @@ public final class ItemStack {
                 SignItem.openSign = null; // SPIGOT-6758 - Reset on early return
                 return enuminteractionresult;
             }
-            world.captureTreeGeneration = false;
 
             if (entityhuman != null && enuminteractionresult.shouldAwardStats()) {
                 org.bukkit.event.block.BlockPlaceEvent placeEvent = null;
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 4247dcb003626535dbb997f48ad9f61380bd17e9..a4326f415f0cdda16c30bf01ca8959bac23a8ab4 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -1,10 +1,7 @@
 package net.minecraft.world.level;
 
-import co.aikar.timings.Timing;
-import co.aikar.timings.Timings;
 import com.destroystokyo.paper.event.server.ServerExceptionEvent;
 import com.destroystokyo.paper.exception.ServerInternalException;
-import com.google.common.base.MoreObjects;
 import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
 import java.io.IOException;
@@ -40,8 +37,6 @@ import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.DifficultyInstance;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.boss.EnderDragonPart;
-import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
 import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
@@ -146,8 +141,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public static final boolean DEBUG_ENTITIES = Boolean.getBoolean("debug.entities"); // Paper
 
     public boolean preventPoiUpdated = false; // CraftBukkit - SPIGOT-5710
-    public boolean captureBlockStates = false;
-    public boolean captureTreeGeneration = false;
+    private boolean captureBlockStates = false; //Paper - made private for better readability
+    private boolean captureTreeGeneration = false; //Paper - made private for better readability
     public Map<BlockPos, org.bukkit.craftbukkit.block.CraftBlockState> capturedBlockStates = new java.util.LinkedHashMap<>(); // Paper
     public Map<BlockPos, BlockEntity> capturedTileEntities = new java.util.LinkedHashMap<>(); // Paper
     public List<ItemEntity> captureDrops;
@@ -177,6 +172,40 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public final Map<Explosion.CacheKey, Float> explosionDensityCache = new HashMap<>(); // Paper - Optimize explosions
     public java.util.ArrayDeque<net.minecraft.world.level.block.RedstoneTorchBlock.Toggle> redstoneUpdateInfos; // Paper - Move from Map in BlockRedstoneTorch to here
 
+    //Paper start - new way to capture state changes
+    public void captureTreeGeneration(Runnable runnable) {
+        boolean oldState = this.captureTreeGeneration;
+        this.captureTreeGeneration = true;
+        runnable.run();
+        this.captureTreeGeneration = oldState;
+    }
+
+    public void captureBlockStates(Runnable runnable) {
+        boolean oldState = this.captureBlockStates;
+        this.captureBlockStates = true;
+        runnable.run();
+        this.captureBlockStates = oldState;
+    }
+
+    public void capture(Runnable runnable, boolean captureBlockStates, boolean captureTreeGeneration) {
+        boolean oldBlockState = this.captureBlockStates;
+        boolean oldTreeState = this.captureTreeGeneration;
+        if(captureBlockStates) {
+            this.captureBlockStates = true;
+        }
+        if(captureTreeGeneration) {
+            this.captureTreeGeneration = true;
+        }
+        runnable.run();
+        this.captureBlockStates = oldBlockState;
+        this.captureTreeGeneration = oldTreeState;
+    }
+
+    public boolean isCapturingBlockStates() {
+        return this.captureBlockStates;
+    }
+    //Paper end
+
     // Paper start - fix and optimise world upgrading
     // copied from below
     public static ResourceKey<DimensionType> getDimensionKey(DimensionType manager) {
diff --git a/src/main/java/net/minecraft/world/level/block/SaplingBlock.java b/src/main/java/net/minecraft/world/level/block/SaplingBlock.java
index d920d127dfe9fdcde8c006cee400b9fabff03971..ec4081974470f251554a1958f215c60a70dede7c 100644
--- a/src/main/java/net/minecraft/world/level/block/SaplingBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/SaplingBlock.java
@@ -41,12 +41,8 @@ public class SaplingBlock extends BushBlock implements BonemealableBlock {
     @Override
     public void randomTick(net.minecraft.world.level.block.state.BlockState state, ServerLevel world, BlockPos pos, Random random) {
         if (world.getMaxLocalRawBrightness(pos.above()) >= 9 && random.nextInt(Math.max(2, (int) (((100.0F / world.spigotConfig.saplingModifier) * 7) + 0.5F))) == 0) { // Spigot
+            world.captureTreeGeneration(() -> this.advanceTree(world, pos, state, random)); //Paper - encapsulate capturing
             // CraftBukkit start
-            world.captureTreeGeneration = true;
-            // CraftBukkit end
-            this.advanceTree(world, pos, state, random);
-            // CraftBukkit start
-            world.captureTreeGeneration = false;
             if (world.capturedBlockStates.size() > 0) {
                 TreeType treeType = SaplingBlock.treeType;
                 SaplingBlock.treeType = null;
diff --git a/src/main/java/net/minecraft/world/level/block/WitherSkullBlock.java b/src/main/java/net/minecraft/world/level/block/WitherSkullBlock.java
index 5be46c6f3db4848b9b88a5227d58705f40b9c16f..f3e631ffe483baeb75b196d854f43c1df126778d 100644
--- a/src/main/java/net/minecraft/world/level/block/WitherSkullBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/WitherSkullBlock.java
@@ -55,7 +55,7 @@ public class WitherSkullBlock extends SkullBlock {
     }
 
     public static void checkSpawn(Level world, BlockPos pos, SkullBlockEntity blockEntity) {
-        if (world.captureBlockStates) return; // CraftBukkit
+        if (world.isCapturingBlockStates()) return; // CraftBukkit, Paper - use new capture method
         if (!world.isClientSide) {
             BlockState iblockdata = blockEntity.getBlockState();
             boolean flag = iblockdata.is(Blocks.WITHER_SKELETON_SKULL) || iblockdata.is(Blocks.WITHER_SKELETON_WALL_SKULL);
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 7567a8bf848c82b27383f084056cb43c41df6d0c..474c2afa529d8e190d09caf72f1934a552863835 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -551,7 +551,7 @@ public class LevelChunk extends ChunkAccess {
                     return null;
                 } else {
                     // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled.
-                    if (!this.level.isClientSide && doPlace && (!this.level.captureBlockStates || block instanceof net.minecraft.world.level.block.BaseEntityBlock)) {
+                    if (!this.level.isClientSide && doPlace && (!this.level.isCapturingBlockStates() || block instanceof net.minecraft.world.level.block.BaseEntityBlock)) { //Paper - use new capture method
                         iblockdata.onPlace(this.level, blockposition, iblockdata1, flag);
                     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index f2deb875992ad2d5c9dbcfe9ee7071a773fed684..268e296fa50b9d56b611c16c0bf4c7b0e4c56de7 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -4,6 +4,7 @@ import com.google.common.base.Preconditions;
 import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import io.papermc.paper.util.Handle; //Paper
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import java.io.File;
@@ -790,11 +791,11 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public boolean generateTree(Location loc, TreeType type, BlockChangeDelegate delegate) {
-        world.captureTreeGeneration = true;
-        world.captureBlockStates = true;
-        boolean grownTree = this.generateTree(loc, type);
-        world.captureBlockStates = false;
-        world.captureTreeGeneration = false;
+        //Paper start - encapsulate capturing
+        Handle<Boolean> grownTreeHandle = new Handle<>(false);
+        world.capture(() -> grownTreeHandle.setValue(this.generateTree(loc, type)), true, true);
+        boolean grownTree = grownTreeHandle.getValue();
+        //Paper end
         if (grownTree) { // Copy block data to delegate
             for (BlockState blockstate : world.capturedBlockStates.values()) {
                 BlockPos position = ((CraftBlockState) blockstate).getPosition();
